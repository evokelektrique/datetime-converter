# **مبدل تاریخ پیشرفته**

این پروژه یک اپلیکیشن تحت وب جامع و مدرن برای تبدیل دقیق تاریخ بین سه تقویم کلیدی **شمسی (خورشیدی)**، **میلادی (گرگوری)** و **قمری (هجری)** است. این ابزار با بهره‌گیری از یک رابط کاربری پویا و زیبا، به کاربران اجازه می‌دهد تا با سرعت و اطمینان بالا، تاریخ‌ها را به یکدیگر تبدیل کرده و اطلاعات تکمیلی ارزشمندی مانند روز هفته و وضعیت سال کبیسه را دریافت کنند.

-----

## **مسئله اصلی که پروژه حل می‌کند**

در بسیاری از کاربردهای فرهنگی، تاریخی، اداری و شخصی، نیاز به کار همزمان با تقویم‌های مختلف یک چالش همیشگی است. تطبیق تاریخ تولد، مناسبت‌های مذهبی، رویدادهای تاریخی یا برنامه‌ریزی‌های بین‌المللی نیازمند یک ابزار دقیق و قابل اعتماد است. این پروژه با هدف ارائه یک راهکار استاندارد، مهندسی‌شده و کاربرپسند برای رفع این نیاز طراحی شده است.

-----

## ✨ **ویژگی‌های کلیدی**

  - **پشتیبانی کامل از سه تقویم اصلی**:

      - تبدیل دوطرفه بین **میلادی** و **شمسی**.
      - تبدیل دوطرفه بین **میلادی** و **قمری**.
      - تبدیل دوطرفه بین **شمسی** و **قمری**.

  - **انتخاب‌گر تاریخ هوشمند و یکپارچه (Unified Smart Date Picker)**:
    این پروژه از یک کتابخانه قدرتمند و مدرن (`react-multi-date-picker`) استفاده می‌کند که به صورت پویا، ظاهر و منطق خود را بر اساس تقویم مبدأ تغییر می‌دهد. زمانی که کاربر "شمسی" را به عنوان مبدأ انتخاب می‌کند، یک تقویم جلالی کاملاً بومی نمایش داده می‌شود. با انتخاب "قمری"، تقویم به هجری با ماه‌های عربی و چیدمان راست‌به‌چپ تغییر می‌کند. این ویژگی تجربه‌ای یکپارچه و بدون سردرگمی را برای کاربر فراهم می‌آورد.

  - **ارائه اطلاعات تکمیلی دقیق**:
    علاوه بر تاریخ تبدیل‌شده، خروجی شامل داده‌های ارزشمند زیر نیز می‌باشد:

      - **روز هفته**: نام دقیق روز در هفته (مثلاً: جمعه).
      - **وضعیت سال کبیسه**: مشخص می‌کند که سال مقصد یک سال عادی است یا کبیسه.

  - **معماری مدرن Client-Server**:
    پروژه با معماری مدرن توسعه داده شده است که در آن، رابط کاربری (Frontend) کاملاً از منطق محاسباتی (Backend) جدا شده و این دو بخش از طریق یک API با یکدیگر ارتباط برقرار می‌کنند.

  - **طراحی واکنش‌گرا (Responsive)**:
    رابط کاربری با استفاده از اصول طراحی مدرن ساخته شده و بر روی تمامی دستگاه‌ها از جمله دسکتاپ، تبلت و موبایل، تجربه‌ای بهینه و زیبا را ارائه می‌دهد.

-----

## ⚙️ **پشته فناوری و جزئیات فنی**

این پروژه با استفاده از مجموعه‌ای از فناوری‌های مدرن و استاندارد در دو بخش Backend و Frontend توسعه داده شده است.

### **بخش سرور (Backend)**

  - **PHP**: به عنوان زبان برنامه‌نویسی سمت سرور برای اجرای منطق اصلی محاسبات.
  - **`CalendarConverter.php`**: این کلاس، هسته محاسباتی و مغز متفکر پروژه است. این کلاس یک پیاده‌سازی شیءگرا و حرفه‌ای از الگوریتم‌های معتبر تبدیل تاریخ است.
  - **`api.php`**: یک اسکریپت سبک که به عنوان یک نقطه پایانی API (API Endpoint) عمل می‌کند. این فایل درخواست‌های JSON را از سمت کلاینت دریافت کرده، آن‌ها را به کلاس `CalendarConverter` ارسال می‌کند و نتیجه را در قالب JSON به کلاینت بازمی‌گرداند.

### **بخش کلاینت (Frontend)**

  - **Vite**: به عنوان ابزار ساخت (Build Tool) و سرور توسعه مدرن که تجربه برنامه‌نویسی بسیار سریعی را با قابلیت‌هایی مانند Hot Module Replacement (HMR) فراهم می‌کند.
  - **React**: به عنوان کتابخانه اصلی برای ساخت رابط کاربری پویا و کامپوننت‌محور. تمام وضعیت‌های برنامه (مانند تاریخ انتخابی، نوع تبدیل و نتایج) توسط هوک‌های React مدیریت می‌شوند.
  - **React Multi-Date Picker**: یک کامپوننت قدرتمند و یکپارچه برای انتخاب تاریخ که از چندین تقویم و زبان به صورت همزمان پشتیبانی می‌کند و هسته اصلی رابط کاربری انتخاب تاریخ را تشکیل می‌دهد.
  - **JavaScript (ES6+) و `fetch` API**: برای مدیریت منطق سمت کلاینت و برقراری ارتباط ناهمزمان (Asynchronous) با API نوشته‌شده در PHP.

-----

## 🏛️ **مبانی تئوری و علمی پروژه**

دقت این پروژه بر پایه اصول علمی و الگوریتم‌های استاندارد بنا شده است.

### **۱. عدد روز ژولینی (Julian Day Number - JD)**

محور اصلی و شاهرگ تمام محاسبات در این پروژه، سیستم **عدد روز ژولینی** است. این سیستم به جای کار با ساختارهای پیچیده سال، ماه و روز، هر تاریخ را به یک عدد اعشاری واحد تبدیل می‌کند که نشان‌دهنده تعداد روزهای سپری شده از یک مبدأ تاریخی ثابت در نجوم است.

  - **چرا از JD استفاده می‌شود؟** این سیستم به عنوان یک "زبان مشترک" یا استاندارد میانی بین تمام تقویم‌ها عمل می‌کند. به جای نوشتن فرمول‌های تبدیل مستقیم و بسیار پیچیده (مثلاً شمسی به قمری)، هر تبدیل به صورت یک فرآیند دو مرحله‌ای انجام می‌شود:
    1.  تاریخ مبدأ به عدد روز ژولینی تبدیل می‌شود.
    2.  عدد روز ژولینی به تاریخ در تقویم مقصد تبدیل می‌گردد.
        این رویکرد، ضمن ساده‌سازی محاسبات، دقت و قابلیت اطمینان آن‌ها را به شدت افزایش می‌دهد.

### **۲. الگوریتم‌های تقویم**

  - **تقویم شمسی (با دقت بالا)**: پس از بررسی‌های متعدد، الگوریتم‌های پیچیده "نجومی" و "حسابی" قدیمی با یک **الگوریتم واحد، مدرن و بسیار دقیق** جایگزین شده‌اند. این الگوریتم جدید که بر اساس محاسبه آفست روزهای سال عمل می‌کند، پایدارتر بوده و نتایجی کاملاً مطابق با تقویم رسمی ایران ارائه می‌دهد و از سردرگمی بین نسخه‌های مختلف جلوگیری می‌کند.
  - **تقویم قمری (محاسباتی)**: تقویم قمری استفاده شده در این پروژه از نوع **محاسباتی (Algorithmic)** است. این تقویم بر اساس یک چرخه ۳۰ ساله عمل می‌کند که در آن ۱۱ سال به صورت ثابت کبیسه در نظر گرفته می‌شوند. این رویکرد کاملاً قابل پیش‌بینی است اما ممکن است با **تقویم قمری استهِلالی** (که بر اساس رؤیت هلال ماه تعیین می‌شود) به اندازه یک یا دو روز اختلاف داشته باشد.

-----

## 🏗️ **معماری پروژه**

پروژه از یک معماری مدرن کلاینت-سرور پیروی می‌کند:

1.  **کلاینت (Frontend)**: یک برنامه تک‌صفحه‌ای (Single Page Application - SPA) است که با Vite و React ساخته شده و در مرورگر کاربر اجرا می‌شود. این بخش مسئولیت کامل رندر کردن رابط کاربری و مدیریت تعاملات را بر عهده دارد.
2.  **سرور (Backend)**: یک API ساده و سبک با PHP است که تنها یک وظیفه دارد: دریافت داده‌های تاریخ، انجام محاسبات سنگین از طریق `CalendarConverter` و بازگرداندن نتیجه.
3.  **ارتباط**: کلاینت و سرور از طریق درخواست‌های `fetch` و با تبادل داده در فرمت JSON با یکدیگر صحبت می‌کنند. این جداسازی کامل، توسعه، تست و نگهداری پروژه را در آینده بسیار آسان‌تر می‌کند.

-----

## 🚀 نصب و راه‌اندازی سریع

برای اجرای این پروژه به صورت محلی، کافی است از اسکریپت‌های آماده شده در ریشه پروژه استفاده کنید.

### **نیازسنجی‌ها**

قبل از شروع، اطمینان حاصل کنید که **PHP** و **Node.js** (به همراه **npm**) بر روی سیستم شما نصب شده و از طریق خط فرمان قابل دسترسی هستند.

-----

### **اسکریپت‌های پروژه**

در ریشه پروژه، چهار اسکریپت برای خودکارسازی فرآیندها قرار داده شده است:

  - `start.sh` (برای لینوکس و macOS): **محیط توسعه** را راه‌اندازی می‌کند. این اسکریپت به صورت خودکار هر دو سرور PHP (برای API) و Vite (برای رابط کاربری) را اجرا می‌کند.

  - `start.bat` (برای ویندوز): عملکردی مشابه `start.sh` دارد و **محیط توسعه** را اجرا می‌کند.

  - `start_production.sh` (برای لینوکس و macOS): **نسخه نهایی (پروداکشن)** برنامه را ساخته و اجرا می‌کند. این اسکریپت ابتدا پروژه را `build` کرده و سپس سرور PHP را برای اجرای نسخه بهینه‌سازی شده، راه‌اندازی می‌کند.

  - `start_production.bat` (برای ویندوز): عملکردی مشابه `start_production.sh` دارد و نسخه **پروداکشن** را اجرا می‌کند.

-----

### **۱. اجرای پروژه در حالت توسعه (Development Mode)**

این حالت برای برنامه‌نویسی و مشاهده تغییرات به صورت زنده مناسب است.

**در لینوکس و macOS:**

1.  ابتدا اسکریپت را اجرایی کنید:
    ```bash
    chmod +x start.sh
    ```
2.  سپس آن را اجرا کنید:
    ```bash
    ./start.sh
    ```

**در ویندوز:**

  - کافی است روی فایل `start.bat` دوبار کلیک کنید.

پس از اجرای اسکریپت، سرورهای لازم به صورت خودکار اجرا می‌شوند. مرورگر خود را باز کرده و به آدرسی که Vite نمایش می‌دهد (معمولاً `http://localhost:5173`) مراجعه کنید.

-----

### **۲. اجرای پروژه در حالت پروداکشن (Production Mode)**

این حالت یک نسخه بهینه‌سازی شده از برنامه را برای استقرار نهایی آماده و اجرا می‌کند.

**در لینوکس و macOS:**

1.  ابتدا اسکریپت را اجرایی کنید:
    ```bash
    chmod +x start_production.sh
    ```
2.  سپس آن را اجرا کنید:
    ```bash
    ./start_production.sh
    ```

**در ویندوز:**

  - کافی است روی فایل `start_production.bat` دوبار کلیک کنید.

این اسکریپت ابتدا فرآیند `build` را انجام داده و سپس سرور را راه‌اندازی می‌کند. می‌توانید نسخه نهایی برنامه را در آدرس `http://localhost:8000` مشاهده کنید.

-----

## 💡 **نکات و ملاحظات مهم**

  - **ارتباط بین دو سرور (CORS)**: در حالت توسعه، فرانت‌اند (روی پورت 5173) و بک‌اند (روی پورت 8000) بر روی دو مبدأ (Origin) متفاوت اجرا می‌شوند. برای اینکه مرورگر اجازه این ارتباط را بدهد، هدرهای CORS (`Access-Control-Allow-Origin: *`) در فایل `api.php` تنظیم شده‌اند.
  - **سرور PHP**: سرور داخلی PHP (`php -S`) برای توسعه و تست سبک فوق‌العاده است، اما برای یک محیط پروداکشن واقعی و پرترافیک، استفاده از وب‌سرورهای قدرتمندتر مانند Nginx یا Apache توصیه می‌شود.